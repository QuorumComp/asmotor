#LyX 1.6.7 created this file. For more info see http://www.lyx.org/
\lyxformat 345
\begin_document
\begin_header
\textclass report
\use_default_options false
\language english
\inputencoding auto
\font_roman default
\font_sans default
\font_typewriter default
\font_default_family default
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100

\graphics default
\paperfontsize default
\spacing single
\use_hyperref false
\papersize a4paper
\use_geometry false
\use_amsmath 1
\use_esint 1
\cite_engine basic
\use_bibtopic false
\paperorientation portrait
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\defskip medskip
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\author "" 
\author "" 
\end_header

\begin_body

\begin_layout Title
ASMotor v0.1.0
\end_layout

\begin_layout Author
Carsten Elton SÃ¸rensen
\end_layout

\begin_layout Part*
ASMotor
\end_layout

\begin_layout Chapter*
Introduction
\end_layout

\begin_layout Standard
ASMotor is a portable and generic assembler engine and development system
 written in ANSI C and licensed under the GNU Public License v3.
 The package consists of the assembler, the librarian and the linker.
 It can be used as either a cross or native development system.
\end_layout

\begin_layout Standard
ASMotor first saw the light of day as RGBDS, a Gameboy development system.
 RGBDS used flex and bison and used two pass assembling.
 Since then it has been rewritten and now features a custom lexer and parser
 and the assembler does its work in only one pass, all of which make it
 much faster than the first versions.
\end_layout

\begin_layout Standard
ASMotor is largely compatible with sources written for RGBDS although there
 have been changes that will break some of this compatibility.
 The bump in the major version number indicates that compatibility is not
 ensured.
 
\end_layout

\begin_layout Section*
Features
\end_layout

\begin_layout Standard
CPU architectures:
\end_layout

\begin_layout Itemize
The Gameboy Z80 derivative
\end_layout

\begin_layout Itemize
MC680x0
\end_layout

\begin_layout Itemize
6502
\end_layout

\begin_layout Itemize
MIPS32
\end_layout

\begin_layout Standard
Object formats:
\end_layout

\begin_layout Itemize
xobj (ASMotor generic format)
\end_layout

\begin_layout Itemize
binary
\end_layout

\begin_layout Itemize
Amiga hunk object
\end_layout

\begin_layout Itemize
Amiga executable
\end_layout

\begin_layout Part*
The assembler
\begin_inset Newline newline
\end_inset

asmotor
\end_layout

\begin_layout Chapter*
Invoking asmotor
\begin_inset Index
status collapsed

\begin_layout Plain Layout
Invoking xasm
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Depending on the target CPU, the executable to invoke will be named motor,
 followed by the CPU architecture name.
 motorgb (for Gameboy), motor68k (for MC680x0), motor6502 (6502 and derivatives)
 or motormips.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

\begin_inset Caption

\begin_layout Plain Layout
Supported command line options
\end_layout

\end_inset

-b<AS>  Change the two characters used for binary constants
\end_layout

\begin_layout Plain Layout

        (default is 01)
\end_layout

\begin_layout Plain Layout

-e(l|b) Change endianness
\end_layout

\begin_layout Plain Layout

-f<f>   Output format, one of
\end_layout

\begin_layout Plain Layout

        x - xobj (default)
\end_layout

\begin_layout Plain Layout

        b - binary file
\end_layout

\begin_layout Plain Layout

        g - Amiga executable file
\end_layout

\begin_layout Plain Layout

        h - Amiga object file
\end_layout

\begin_layout Plain Layout

-i<dir> Extra include path (can appear more than once)
\end_layout

\begin_layout Plain Layout

-o<f>   Write assembly output to <file>
\end_layout

\begin_layout Plain Layout

-v      Verbose text output
\end_layout

\begin_layout Plain Layout

-w<d>   Disable warning <d> (four digits)
\end_layout

\begin_layout Plain Layout

-z<XX>  Set the byte value (hex format) used for uninitialised
\end_layout

\begin_layout Plain Layout

        data (default is ? for random) 
\end_layout

\end_inset


\end_layout

\begin_layout Chapter*
Syntax
\end_layout

\begin_layout Standard
The syntax is line based.
 A valid line consists of an optional label, an optional machine or assembler
 instruction and an optional comment.
 Labels are described
\begin_inset CommandInset ref
LatexCommand vpageref
reference "cha:Symbols-and-labels"

\end_inset

, assembler instructions
\begin_inset CommandInset ref
LatexCommand vpageref
reference "cha:The-macro-language"

\end_inset

.
\end_layout

\begin_layout Section*
Comments
\begin_inset Index
status collapsed

\begin_layout Plain Layout
Comments
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Comments are ignored during assembling.
 They are an important part of writing code, this is especially true for
 assembly where comments are essential for documenting what a function does
 as it's not immediatly obvious as it may be in a high level language.
\end_layout

\begin_layout Standard
Comments are usually started with a semi-colon and end at the end of the
 line.
 A comment may also be started with a whitespace character (including a
 line break) followed by an asterisk.
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\ttfamily}"
inline false
status open

\begin_layout Plain Layout

\begin_inset Caption

\begin_layout Plain Layout
Comment examples
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

* These are comment examples
\end_layout

\begin_layout Plain Layout

Label:  moveq   #1,d0   ;load register d0 with the value 1
\end_layout

\begin_layout Plain Layout

        move.l  d0,d1   *copy it to d1
\end_layout

\end_inset


\end_layout

\begin_layout Chapter*
Labels
\begin_inset CommandInset label
LatexCommand label
name "cha:Symbols-and-labels"

\end_inset


\end_layout

\begin_layout Standard
One of the assembler's main tasks is to keep track of addresses so you don't
 have to remember obscure numbers but can use a meaningful name instead,
 a label.
 Labels are always placed at the beginning of a line.
\end_layout

\begin_layout Standard
Labels end with zero, one or two colons.
 If the label ends with two colons it will be automatically exported
\begin_inset Foot
status open

\begin_layout Plain Layout
see XDEF reference
\begin_inset CommandInset ref
LatexCommand vpageref
reference "sec:Exporting-and-importing"

\end_inset

 and examples
\begin_inset CommandInset ref
LatexCommand vpageref
reference "sec:Exporting-and-importing"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Symbols and labels are always case-sensitive.
\end_layout

\begin_layout Section*
Global labels
\begin_inset Index
status collapsed

\begin_layout Plain Layout
Labels, global
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Global labels start with a character from A to Z (or their lower case equivalent
s) or an underscore.
 After that the characters a-z, A-Z, 0-9, _, @ and # may be used.
 A global label also marks the beginning of a new scope for local labels.
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\ttfamily}"
inline false
status open

\begin_layout Plain Layout

\begin_inset Caption

\begin_layout Plain Layout
Label examples
\end_layout

\end_inset

GlobalLabel
\end_layout

\begin_layout Plain Layout

AnotherGlobalLabel:
\end_layout

\begin_layout Plain Layout

ExportedLabel::
\end_layout

\end_inset


\end_layout

\begin_layout Section*
Local labels
\begin_inset Index
status collapsed

\begin_layout Plain Layout
Labels, local
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The assembler supports local labels.
 Local labels start with the .
 character, followed by a character in the range a-z, A-Z or an underscore,
 after which the characters a-z, A-Z, 0-9, _, @ and # may be used.
 A local label is considered local to the scope in which it is defined,
 a scope begins with a global label and ends with the next global label.
 Local labels can only be referenced within the scope they are defined.
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\ttfamily}"
inline false
status open

\begin_layout Plain Layout

\begin_inset Caption

\begin_layout Plain Layout
Local label examples
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

GlobalLabel:
\end_layout

\begin_layout Plain Layout

.locallabel
\end_layout

\begin_layout Plain Layout

AnotherGlobalLabel:
\end_layout

\end_inset


\end_layout

\begin_layout Section*
Exporting and importing labels
\begin_inset Index
status collapsed

\begin_layout Plain Layout
Labels, export and import
\end_layout

\end_inset


\begin_inset CommandInset label
LatexCommand label
name "sec:Exporting-and-importing"

\end_inset


\end_layout

\begin_layout Standard
Most of the time programs consists of several source files that are assembled
 individually and the resulting object files then linked into an executable.
 This improves the time spent assembling and help manage a project.
\end_layout

\begin_layout Standard
To export a symbol (to let other source files use the symbol,) you use the
 keyword EXPORT
\begin_inset Index
status open

\begin_layout Plain Layout
EXPORT
\end_layout

\end_inset

 (or its synonym XDEF
\begin_inset Index
status open

\begin_layout Plain Layout
XDEF
\end_layout

\end_inset

) followed by the symbol that should be exported.
 To import a symbol (to make an externally defined symbol available in the
 current source file,) the keyword IMPORT
\begin_inset Index
status open

\begin_layout Plain Layout
IMPORT
\end_layout

\end_inset

 (or its synonym XREF
\begin_inset Index
status open

\begin_layout Plain Layout
XREF
\end_layout

\end_inset

) is used.
\end_layout

\begin_layout Standard
Instead of using EXPORT or XDEF to export a label, the label may end with
 two colons.
\end_layout

\begin_layout Standard
Often you will want to make a header file for these definitions that other
 source files can include for easy access to the symbols you have exported.
 However, if you want to include the file yourself, for instance if it contains
 structure definitions, it becomes slightly complicated - if a symbol is
 first imported in the include file and later appears as a label, you have
 multiple definitions of the symbol.
\end_layout

\begin_layout Standard
The assembler provides a third keyword, GLOBAL
\begin_inset Index
status open

\begin_layout Plain Layout
GLOBAL
\end_layout

\end_inset

, that either imports or exports a symbol, depending on whether it appears
 as a label in the current source file.
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\ttfamily}"
inline false
status open

\begin_layout Plain Layout

\begin_inset Caption

\begin_layout Plain Layout
Import and export examples
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

EXPORT  GlobalLabel
\end_layout

\begin_layout Plain Layout

XREF    ImportedLabel
\end_layout

\begin_layout Plain Layout

GLOBAL  AnotherImport,AnExportedLabel
\end_layout

\begin_layout Plain Layout

GlobalLabel:
\end_layout

\begin_layout Plain Layout

AnExportedLabel:
\end_layout

\begin_layout Plain Layout

AutomaticExport::
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Note that all three assembler instructions accept a comma separated list
 of labels.
\end_layout

\begin_layout Section*
Integer symbols
\begin_inset Index
status collapsed

\begin_layout Plain Layout
Symbols, integer
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Instead of hardcoding constants it's often better to give them a name.
 The assembler supports two kinds of integer symbols, one that is constant
 and one that may change its value during assembling.
 The assembler instruction EQU is used to define constants and SET is used
 for variables.
 Instead of SET it's also possible use =.
 Note that an integer symbol is never followed by a colon.
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\ttfamily}"
inline false
status open

\begin_layout Plain Layout

\begin_inset Caption

\begin_layout Plain Layout
Constant and variable examples
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

INTF_MASTER EQU $4000
\end_layout

\begin_layout Plain Layout

MyCounter   SET 0
\end_layout

\begin_layout Plain Layout

MyCounter   =   MyCounter+1 ;Increment MyCounter
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Integer symbols are often used to define the offsets of structure members.
 While the EQU instruction can be used for this it quickly becomes cumbersome
 when adding, reordering or removing members from the structure.
 The assembler provides a group of instructions to make this easier, the
 RS group of instructions.
\end_layout

\begin_layout List
\labelwidthstring 00.00.0000
\begin_inset Tabular
<lyxtabular version="3" rows="6" columns="2">
<features booktabs="true">
<column alignment="left" valignment="top" width="0">
<column alignment="left" valignment="top" width="0">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Command
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Meaning
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
RSRESET
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Resets the __RS counter to zero
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
RSSET constexpr
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Sets the __RS counter to the value of constexpr
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Symbol: RB constexpr
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Sets Symbol to __RS and adds constexpr to __RS
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Symbol: RW constexpr
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Sets Symbol to __RS and adds 2*constexpr to __RS
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Symbol: RL constexpr
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Sets Symbol to __RS and adds 4*constexpr to __RS
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\ttfamily},language={[Motorola68k]Assembler}"
inline false
status open

\begin_layout Plain Layout

\begin_inset Caption

\begin_layout Plain Layout
RS example
\end_layout

\end_inset

           RSRESET
\end_layout

\begin_layout Plain Layout

str_pStuff RW 1
\end_layout

\begin_layout Plain Layout

str_tData  RB 256
\end_layout

\begin_layout Plain Layout

str_bCount RB 1
\end_layout

\begin_layout Plain Layout

str_SIZEOF RB 0
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The example defines four equated symbols and their values:
\end_layout

\begin_layout List
\labelwidthstring 00.00.0000
\begin_inset Tabular
<lyxtabular version="3" rows="5" columns="2">
<features booktabs="true">
<column alignment="left" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Symbol
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Value
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
str_pStuff
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
str_tData
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
str_bCount
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
258
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
str_SIZEOF
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
259
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Standard
Like labels constants can also be exported, if the chosen object format
 supports it.
\end_layout

\begin_layout Section*
String symbols
\begin_inset CommandInset label
LatexCommand label
name "sec:String-symbols"

\end_inset


\begin_inset Index
status collapsed

\begin_layout Plain Layout
Symbols, strings
\end_layout

\end_inset


\end_layout

\begin_layout Standard
String symbols are used to assign a name to an often used string.
 These symbols are expanded to their value whenever the assembler encounters
 the assigned name.
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\ttfamily}"
inline false
status open

\begin_layout Plain Layout

\begin_inset Caption

\begin_layout Plain Layout
String symbol example
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

COUNTREG EQUS "[hl+]"
\end_layout

\begin_layout Plain Layout

         ld   a,COUNTREG
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The example above will be interpreted as
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\ttfamily}"
inline false
status open

\begin_layout Plain Layout

\begin_inset Caption

\begin_layout Plain Layout
String symbol expansion
\end_layout

\end_inset

         ld   a,[hl+]
\end_layout

\end_inset


\end_layout

\begin_layout Standard
String symbols can also be used to define small macros
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\ttfamily}"
inline false
status open

\begin_layout Plain Layout

\begin_inset Caption

\begin_layout Plain Layout
Multiline string symbol
\end_layout

\end_inset

PUSHA    EQUS "push af
\backslash
npush bc
\backslash
npush de
\backslash
npush hl
\backslash
n"
\end_layout

\end_inset


\end_layout

\begin_layout Section*
Predeclared symbols
\begin_inset Index
status collapsed

\begin_layout Plain Layout
Symbols, predeclared
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The assembler declares several symbols:
\end_layout

\begin_layout Standard
\begin_inset Tabular
<lyxtabular version="3" rows="8" columns="3">
<features booktabs="true">
<column alignment="left" valignment="top" width="0">
<column alignment="left" valignment="top" width="0">
<column alignment="left" valignment="top" width="0">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Name
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Contents
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Type
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
@, *
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Current PC value
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
EQU
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
__RS
\begin_inset Index
status open

\begin_layout Plain Layout
__RS
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
__RS counter
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
SET
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
__NARG
\begin_inset Index
status open

\begin_layout Plain Layout
__NARG
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Number of arguments passed to macro
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
EQU
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
__LINE
\begin_inset Index
status open

\begin_layout Plain Layout
__LINE
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
The current line number
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
EQU
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
__FILE
\begin_inset Index
status open

\begin_layout Plain Layout
__FILE
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
The current filename
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
EQUS
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
__DATE
\begin_inset Index
status open

\begin_layout Plain Layout
__DATE
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Todays date
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
EQUS
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
__TIME
\begin_inset Index
status open

\begin_layout Plain Layout
__TIME
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
The current time
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
EQUS
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Chapter*
Code, data and variables
\end_layout

\begin_layout Standard
From the assembler's point of view, there is no difference between code
 and data.
 Code is entered by using the mnemonics described in the relevant backend
 chapters.
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\ttfamily}"
inline false
status open

\begin_layout Plain Layout

\begin_inset Caption

\begin_layout Plain Layout
Code example
\end_layout

\end_inset

mfhi t0
\end_layout

\begin_layout Plain Layout

nop
\end_layout

\begin_layout Plain Layout

nop
\end_layout

\begin_layout Plain Layout

mult t0,t1
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Data (or instructions) can also be entered using data declaration statements:
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\ttfamily}"
inline false
status open

\begin_layout Plain Layout

DC.W $4E75
\end_layout

\begin_layout Plain Layout

DC.B "This is a string",0
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The data declaration statements may be called something different depending
 on the CPU backend.
 Please refer to the relevant backend chapter.
\end_layout

\begin_layout Standard
Data can also be declared by simply including a binary file directly from
 the file system:
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\ttfamily}"
inline false
status open

\begin_layout Plain Layout

\begin_inset Caption

\begin_layout Plain Layout
Binary file inclusion
\end_layout

\end_inset

        SECTION "Graphics",DATA
\end_layout

\begin_layout Plain Layout

Ship:   INCBIN "Spaceship.bin"
\end_layout

\end_inset


\end_layout

\begin_layout Section*
Sections
\begin_inset Index
status open

\begin_layout Plain Layout
Sections
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Code, data and variables are organised in sections.
 Before any mnemonics or data declarations can be used, a section must be
 declared.
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\ttfamily}"
inline false
status open

\begin_layout Plain Layout

\begin_inset Caption

\begin_layout Plain Layout
A simple code section
\end_layout

\end_inset

SECTION "A_Code_Section",CODE
\end_layout

\end_inset


\end_layout

\begin_layout Standard
This will switch to the section 
\begin_inset Quotes eld
\end_inset

A_Code_Section
\begin_inset Quotes erd
\end_inset

 if it is already known (and its type matches), or declare it if it doesn't.
 DATA
\begin_inset Index
status open

\begin_layout Plain Layout
DATA
\end_layout

\end_inset

 may also be used instead of CODE
\begin_inset Index
status open

\begin_layout Plain Layout
CODE
\end_layout

\end_inset

, they are synonymous.
\end_layout

\begin_layout Standard
Variables are usually placed in a BSS
\begin_inset Index
status open

\begin_layout Plain Layout
BSS
\end_layout

\end_inset

 section.
 BSS section cannot contain initialised data, typically only the DS
\begin_inset Index
status open

\begin_layout Plain Layout
DS
\end_layout

\end_inset

 command is used.
 However, it is also possible to use the DB
\begin_inset Index
status open

\begin_layout Plain Layout
DB
\end_layout

\end_inset

, DW
\begin_inset Index
status open

\begin_layout Plain Layout
DW
\end_layout

\end_inset

 and DL
\begin_inset Index
status open

\begin_layout Plain Layout
DL
\end_layout

\end_inset

 commands without any arguments.
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\ttfamily}"
inline false
status open

\begin_layout Plain Layout

\begin_inset Caption

\begin_layout Plain Layout
Variable section
\end_layout

\end_inset

        SECTION "Variables",BSS
\end_layout

\begin_layout Plain Layout

Foo:    DB            ; Reserve one byte for Foo
\end_layout

\begin_layout Plain Layout

Bar:	DW            ; Reserve a word for Bar
\end_layout

\begin_layout Plain Layout

Baz:	DS str_SIZEOF ; Reserve str_SIZEOF bytes for Baz
\end_layout

\end_inset


\end_layout

\begin_layout Standard
If the chosen object output format supports it, you can force a section
 into a specific address:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

\begin_inset Caption

\begin_layout Plain Layout
Section fixed to address
\end_layout

\end_inset

        SECTION "LoadSection",CODE[$F000]
\end_layout

\begin_layout Plain Layout

Code:   xor a
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The different CPU backends may support additional section types and other
 options.
 Please refer to the relevant chapters.
\end_layout

\begin_layout Section*
The section stack
\end_layout

\begin_layout Standard
A section stack is available, which is particularly useful when defining
 sections in included files (or macros) and it's necessary to preserve the
 section context for the program that included the file or called the macro.
 
\end_layout

\begin_layout Standard
POPS
\begin_inset Index
status open

\begin_layout Plain Layout
POPS
\end_layout

\end_inset

 and PUSHS
\begin_inset Index
status open

\begin_layout Plain Layout
PUSHS
\end_layout

\end_inset

 provide the interface to the section stack.
 PUSHS will push the current section context on the section stack.
 POPS can then later be used to restore it.
 
\end_layout

\begin_layout Chapter*
The macro language
\begin_inset CommandInset label
LatexCommand label
name "cha:The-macro-language"

\end_inset


\end_layout

\begin_layout Standard
The macro language is an interpreted language that offers features which
 make an assembly source more readable.
 It also offers fine control over how the source is assembled.
\end_layout

\begin_layout Section*
Integer expressions
\end_layout

\begin_layout Standard
Whenever the assembler expects an integer, an integer expression may be
 used.
 Integer expressions are always evaluated using signed 32 bit math.
\end_layout

\begin_layout Standard
The simplest integer expression is a number.
\end_layout

\begin_layout Standard
An expression is said to be constant when it doesn't change its value during
 linking.
 This basically means that you can't use labels in those expressions.
 The instructions in the macro-language all require expressions that are
 constant
\end_layout

\begin_layout Subsection*
Integer literals
\end_layout

\begin_layout Standard
The assembler supports several numeric formats:
\end_layout

\begin_layout Description
Hexadecimal $0123456789ABCDEF (case-insensitive)
\end_layout

\begin_layout Description
Decimal 0123456789
\end_layout

\begin_layout Description
Binary %01
\end_layout

\begin_layout Description
Fixedpoint
\begin_inset space ~
\end_inset

(16.16) 01234.56789
\end_layout

\begin_layout Description
Character "ABYZ"
\end_layout

\begin_layout Subsection*
Operators
\end_layout

\begin_layout Standard
Several operators can be used to build up integer expressions.
 In order of precedence they are:
\end_layout

\begin_layout List
\labelwidthstring 00.00.0000
\begin_inset Tabular
<lyxtabular version="3" rows="11" columns="2">
<features booktabs="true">
<column alignment="center" valignment="top" width="0">
<column alignment="left" valignment="top" width="40page%">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Operator
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Meaning
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
( )
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Precedence override
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
FunctionName(...)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Function call
\end_layout

\end_inset
</cell>
</row>
<row>
<cell multicolumn="1" alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
~ + -
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Unary bitwise not, plus, negation
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
* / ~/ ** //
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Multiply, divide, modulo, fixedpoint multiply and divide
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
<< >>
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Shift left, shift right
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
& ^ |
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Bitwise and, bitwise exclusive or, bitwise or
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
+ -
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Add, subtract
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
~= == <= >= < >
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Comparison operators: not equal, equal, less than or equal, greater than
 or equal, less than, greater than
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
&& ||
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Boolean and, boolean or
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
~!
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Unary boolean not
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Standard
The result of the boolean operators and comparison operators is zero if
 when 
\emph on
false
\emph default
 and non-zero when 
\emph on
true
\emph default
.
\end_layout

\begin_layout Section*
Fixed point math
\end_layout

\begin_layout Standard
The assembler supports fixed point constants, which are normal 32 bit constants
 where the upper 16 bits are used for the integer part and the lower 16
 bits are used for the fraction (65536ths).
\end_layout

\begin_layout Standard
Fixed point values can be used in normal integer expressions, some integer
 operators like plus and minus work the same whether the operands are integer
 or fixed point.
 A fixed point number can be converted to an integer by shifting it right
 16 bits, as this will discard the fractional part and leave the integer
 part at the right bit position.
 It follows that you can convert an integer to a fixed point number by shifting
 it left 16 positions.
\end_layout

\begin_layout Standard
Other fixed point operations require more precision than 32 bit math provides,
 the following fixed point functions are therefore available:
\end_layout

\begin_layout List
\labelwidthstring 00.00.0000
\begin_inset Tabular
<lyxtabular version="3" rows="10" columns="2">
<features booktabs="true">
<column alignment="center" valignment="top" width="0">
<column alignment="left" valignment="top" width="0">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Name
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Operation
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\emph on
x
\emph default
 // 
\emph on
y
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $x/y$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\emph on
x
\emph default
 ** 
\emph on
y
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $x*y$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
SIN(
\emph on
x
\emph default
)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $sin(x)$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
COS(
\emph on
x
\emph default
)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $cos(x)$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
TAN(
\emph on
x
\emph default
)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $tan(x)$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
ASIN(
\emph on
x
\emph default
)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $sin{}^{\text{-1}}(x)$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
ACOS(
\emph on
x
\emph default
)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $cos{}^{\text{-1}}(x)$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
ATAN(
\emph on
x
\emph default
)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $tan^{\text{-1}}(x)$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
ATAN2(
\emph on
x
\emph default
,
\emph on
y
\emph default
)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Angle of the vector 
\begin_inset Formula $\left[\begin{array}{c}
x\\
y\end{array}\right]$
\end_inset


\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Standard
A circle has 1.0 fixed point degrees (65536 integer), sine values are in
 the range 
\begin_inset Formula $\left[-1.0;1.0\right]$
\end_inset


\end_layout

\begin_layout Standard
These functions are particularly useful for generating various tables:
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\ttfamily}"
inline false
status open

\begin_layout Plain Layout

\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "Sine-table-example"

\end_inset

Generate a 256 byte sine table with values between 0 and 128
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

ANGLE   SET     0.0
\end_layout

\begin_layout Plain Layout

        REPT    256
\end_layout

\begin_layout Plain Layout

        DB      (64.0**SIN(ANGLE)+64.0)>>16
\end_layout

\begin_layout Plain Layout

ANGLE   SET     ANGLE+1.0/256
\end_layout

\begin_layout Plain Layout

        ENDR
\end_layout

\end_inset


\end_layout

\begin_layout Section*
String expressions
\begin_inset Index
status open

\begin_layout Plain Layout
String expressions
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Whenever the assembler excepts a string literal, a string expression may
 be used instead.
 The simplest string expression is a string literal - a string contained
 in double quotes.
 A string literal can also contain special characters, such as newlines
 and tabs by using escape sequences initiated by a backslash:
\end_layout

\begin_layout List
\labelwidthstring 00.00.0000
\begin_inset Tabular
<lyxtabular version="3" rows="9" columns="2">
<features booktabs="true">
<column alignment="center" valignment="top" width="0">
<column alignment="left" valignment="top" width="0">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Sequence
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Meaning
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\backslash

\backslash

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\backslash

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\backslash

\begin_inset Quotes erd
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Quotes eld
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\backslash
{
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
{
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\backslash
}
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
}
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\backslash
n
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Newline ($0A)
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\backslash
t
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Tab ($09)
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\backslash
0 ..
 
\backslash
9
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Value of macro argument
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\backslash
@
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Unique label suffix
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Standard
The macro arguments are only valid within a macro, the 
\backslash
@ sequence is valid in macros and REPT blocks.
\end_layout

\begin_layout Standard
Within a string literal it's possible to embed the value of a symbol.
 This is done by encloding the symbol name in curly brackets:
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\ttfamily}"
inline false
status open

\begin_layout Plain Layout

\begin_inset Caption

\begin_layout Plain Layout
Symbol embedded in string literal
\end_layout

\end_inset

StringSymbol EQUS "A String"
\end_layout

\begin_layout Plain Layout

             DB   "Store the value {StringSymbol}",0
\end_layout

\end_inset


\end_layout

\begin_layout Standard
As a shorthand, a symbol can simply be surrounded by curly brackets outside
 a string literal, to convert its value to a string expression:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

\begin_inset Caption

\begin_layout Plain Layout
Converting a symbol to string expression
\end_layout

\end_inset

StringSymbol EQUS "Another string"
\end_layout

\begin_layout Plain Layout

             DB   {StringSymbol} ; The value of StringSymbol will be stored
\end_layout

\end_inset


\end_layout

\begin_layout Section*
String functions and properties
\end_layout

\begin_layout Standard
Several functions that work on string expressions are available.
 Some of these return strings and some return integers.
 Functions that return an integer can be used as part of integer expressions,
 when a string is returned the function can be used in a string expression.
\end_layout

\begin_layout List
\labelwidthstring 00.00.0000
\begin_inset Tabular
<lyxtabular version="3" rows="10" columns="3">
<features>
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="left" valignment="top" width="0">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Name
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Type
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Result
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\emph on
s
\emph default
.length
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
integer
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
The number of characters in 
\emph on
s
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\emph on
s1
\emph default
.compareto(
\emph on
s2
\emph default
)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
integer
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Negative if 
\emph on
s1
\emph default
 is alphabetically < 
\emph on
s2
\emph default
, 0 if equal, positive if >
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\emph on
s1
\emph default
.indexof(
\emph on
s2
\emph default
)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
integer
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
The position of 
\emph on
s2
\emph default
 within 
\emph on
s1
\emph default
, -1 if not found
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\emph on
s1
\emph default
==
\emph on
s2
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
integer
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Non-zero if 
\emph on
s1
\emph default
 is equal to 
\emph on
s2
\emph default
, otherwise zero
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
~= < <= > >=
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
integer
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
String comparison operators.
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\emph on
s1
\emph default
+
\emph on
s2
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
string
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
String concatenation, 
\emph on
s1
\emph default
 followed by 
\emph on
s2
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\emph on
s
\emph default
.slice(
\emph on
pos
\emph default
,
\emph on
count
\emph default
)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
string
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\emph on
count
\emph default
 characters from 
\emph on
s
\emph default
, starting at 
\emph on
pos
\emph default
 
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\emph on
s
\emph default
.toupper()
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
string
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Upper case version of 
\emph on
s
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\emph on
s
\emph default
.tolower()
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
string
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Lower case version of 
\emph on
s
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Standard
The 
\emph on
pos
\emph default
 parameter for .slice() may also be a negative number, in which case the
 position is relative to the end of the string, with -1 being the last character
 of the string.
 
\emph on
count
\emph default
 may be completely omitted, in which case characters from 
\emph on
pos
\emph default
 until the end of the string is returned.
\end_layout

\begin_layout Section*
Outputting messages
\end_layout

\begin_layout Standard
While assembling it is possible to cause the assembler to print out various
 user defined messages.
\end_layout

\begin_layout Standard
Simple diagnostic messages are possible with PRINTT
\begin_inset Index
status collapsed

\begin_layout Plain Layout
PRINTT
\end_layout

\end_inset

, PRINTF
\begin_inset Index
status collapsed

\begin_layout Plain Layout
PRINTF
\end_layout

\end_inset

 and PRINTV
\begin_inset Index
status collapsed

\begin_layout Plain Layout
PRINTV
\end_layout

\end_inset

:
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\ttfamily}"
inline false
status open

\begin_layout Plain Layout

PRINTT "A simple message
\backslash
n" ; Remember 
\backslash
n for newline
\end_layout

\begin_layout Plain Layout

PRINTV (2+3)/5              ; Prints an integer
\end_layout

\begin_layout Plain Layout

PRINTF 3.14**,2             ; Prints a fixed point value
\end_layout

\end_inset


\end_layout

\begin_layout Standard
In macros it can be helpful to warn the user of a wrong argument or completely
 abort the assembly process.
 This is possible with the FAIL
\begin_inset Index
status open

\begin_layout Plain Layout
FAIL
\end_layout

\end_inset

 and WARN
\begin_inset Index
status open

\begin_layout Plain Layout
WARN
\end_layout

\end_inset

 commands.
 FAIL and WARN take a string as the only argument and will print it out
 as a regular warning or error with a line number.
\end_layout

\begin_layout Standard
FAIL stops assembling immediately while WARN continues after printing the
 errormessage.
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\ttfamily}"
inline false
status open

\begin_layout Plain Layout

\begin_inset Caption

\begin_layout Plain Layout
FAIL and WARN example
\end_layout

\end_inset

IF (
\backslash
1)<42
\end_layout

\begin_layout Plain Layout

WARN "Argument should be >= 42"
\end_layout

\begin_layout Plain Layout

ENDC
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

IF (
\backslash
1)>100
\end_layout

\begin_layout Plain Layout

FAIL "Argument MUST be <= 100"
\end_layout

\begin_layout Plain Layout

ENDC
\end_layout

\end_inset


\end_layout

\begin_layout Section*
Including files
\end_layout

\begin_layout Standard
The INCLUDE
\begin_inset Index
status open

\begin_layout Plain Layout
INCLUDE
\end_layout

\end_inset

 command is used to process another assembly file and then return to the
 current file when done.
 If the file is not found in the current directory, the include path list
 will be searched.
 INCLUDE files may be nested.
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\ttfamily}"
inline false
status open

\begin_layout Plain Layout

\begin_inset Caption

\begin_layout Plain Layout
INCLUDE example
\end_layout

\end_inset

INCLUDE "irq.inc"
\end_layout

\end_inset


\end_layout

\begin_layout Section*
Repeating blocks
\end_layout

\begin_layout Standard
To repeat a block it can be placed inside a REPT
\begin_inset Index
status open

\begin_layout Plain Layout
REPT
\end_layout

\end_inset

/ENDR
\begin_inset Index
status open

\begin_layout Plain Layout
ENDR
\end_layout

\end_inset

 structure.
 The REPT construct repeats the block a specified number of times.
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\ttfamily}"
inline false
status open

\begin_layout Plain Layout

\begin_inset Caption

\begin_layout Plain Layout
Basic REPT example
\end_layout

\end_inset

REPT 4
\end_layout

\begin_layout Plain Layout

add  a,c
\end_layout

\begin_layout Plain Layout

ENDR
\end_layout

\end_inset


\end_layout

\begin_layout Standard
REPT can also be used to repeat macro language constructs such as IF/ENDC
 and used to construct various tables (example 
\begin_inset CommandInset ref
LatexCommand vpageref
reference "Sine-table-example"

\end_inset

.)
\end_layout

\begin_layout Section*
Conditional assembling
\end_layout

\begin_layout Standard
The IF/ELSE/ENDC commands are used to conditionally include or exclude parts
 of an assembly file.
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\ttfamily}"
inline false
status open

\begin_layout Plain Layout

IF     2+2==4
\end_layout

\begin_layout Plain Layout

PRINTT "2+2==4
\backslash
n"
\end_layout

\begin_layout Plain Layout

ELSE
\end_layout

\begin_layout Plain Layout

PRINTT "2+2!=4
\backslash
n"
\end_layout

\begin_layout Plain Layout

ENDC
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The ELSE block is optional.
\end_layout

\begin_layout Standard
While the integer operators can be used to test for many conditions, the
 assembler also supports the traditional IF commands:
\end_layout

\begin_layout List
\labelwidthstring 00.00.0000
\begin_inset Tabular
<lyxtabular version="3" rows="11" columns="2">
<features booktabs="true">
<column alignment="center" valignment="top" width="0">
<column alignment="left" valignment="top" width="0">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Command
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
True when
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
IFC 
\emph on
s1
\emph default
,
\emph on
s2
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
The string 
\emph on
s1
\emph default
 equals the string 
\emph on
s2
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
IFNC 
\emph on
s1
\emph default
,
\emph on
s2
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
The string 
\emph on
s1
\emph default
 is different from the string 
\emph on
s2
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
IFD 
\emph on
symbol
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
The symbol 
\emph on
symbol
\emph default
 is defined
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
IFND 
\emph on
symbol
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
The symbol 
\emph on
symbol
\emph default
 is not defined
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
IFEQ 
\emph on
n
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\emph on
n
\emph default
 equals zero
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
IFNE 
\emph on
n
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\emph on
n
\emph default
 is not equal to zero
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
IFGE 
\emph on
n
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\emph on
n
\emph default
 is greater than or equal to zero
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
IFGT 
\emph on
n
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\emph on
n
\emph default
 is greater than zero
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
IFLE 
\emph on
n
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\emph on
n
\emph default
 is less than or equal to zero
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
IFLT 
\emph on
n
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\emph on
n
\emph default
 is less than zero
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Section*
Macros
\begin_inset Index
status collapsed

\begin_layout Plain Layout
Macros
\end_layout

\end_inset


\end_layout

\begin_layout Standard
One of the most useful features of an assembler is the ability to write
 macros.
 Macros also provide a method of passing arguments to them and they can
 then react to the input using conditional assembling constructs.
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\ttfamily}"
inline false
status open

\begin_layout Plain Layout

\begin_inset Caption

\begin_layout Plain Layout
Macro example
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

MyMacro: MACRO
\end_layout

\begin_layout Plain Layout

         ld   a,80
\end_layout

\begin_layout Plain Layout

         call MyFunc
\end_layout

\begin_layout Plain Layout

         ENDM
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The example above is a very simple macro.
 You use the macro by using its name where you would normally use an instruction.
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\ttfamily}"
inline false
status open

\begin_layout Plain Layout

\begin_inset Caption

\begin_layout Plain Layout
Macro expansion
\end_layout

\end_inset

         add a,b
\end_layout

\begin_layout Plain Layout

         ld  sp,hl
\end_layout

\begin_layout Plain Layout

         MyMacro  ;This will be expanded
\end_layout

\begin_layout Plain Layout

         sub a,87
\end_layout

\end_inset


\end_layout

\begin_layout Standard
When the assembler sees MyMacro it will insert the macro definition, the
 text enclosed in MACRO/ENDM.
\end_layout

\begin_layout Subsection*
Macro loops
\begin_inset Index
status collapsed

\begin_layout Plain Layout
Macro loops
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Often macros will contains loops, such as:
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\ttfamily}"
inline false
status open

\begin_layout Plain Layout

\begin_inset Caption

\begin_layout Plain Layout
Macro with loop
\end_layout

\end_inset

LoopMacro: MACRO
\end_layout

\begin_layout Plain Layout

           xor a,a
\end_layout

\begin_layout Plain Layout

.loop      ld  [hl+],a
\end_layout

\begin_layout Plain Layout

           dec c
\end_layout

\begin_layout Plain Layout

           jr  nz,.loop
\end_layout

\begin_layout Plain Layout

           ENDM
\end_layout

\end_inset


\end_layout

\begin_layout Standard
This will work fine, until you start using the macro more than once per
 scope.
 To get around this problem there is a special label string equate called
 
\backslash
@ that you can append to your labels and it will then expand to a unique
 string.
 
\backslash
@ also works in REPT-blocks.
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\ttfamily}"
inline false
status open

\begin_layout Plain Layout

\begin_inset Caption

\begin_layout Plain Layout
Macro with unique local label
\end_layout

\end_inset

LoopMacro: MACRO
\end_layout

\begin_layout Plain Layout

           xor a,a
\end_layout

\begin_layout Plain Layout

.loop
\backslash
@    ld  [hl+],a
\end_layout

\begin_layout Plain Layout

           dec c
\end_layout

\begin_layout Plain Layout

           jr  nz,.loop
\backslash
@
\end_layout

\begin_layout Plain Layout

           ENDM
\end_layout

\end_inset


\end_layout

\begin_layout Subsection*
Arguments
\begin_inset Index
status collapsed

\begin_layout Plain Layout
Macro arguments
\end_layout

\end_inset


\end_layout

\begin_layout Standard
LoopMacro above could be improved, it would be better if the user didn't
 have to preload the registers with values and then call the macro.
 Fortunately it's possible to pass arguments to a macro, the LoopMacro example
 would then be able to load the registers itself.
\end_layout

\begin_layout Standard
In macros you can get the arguments by using the special macro string equates
 
\backslash
1 through 
\backslash
9, 
\backslash
1 being the first argument specified on the call of the macro.
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\ttfamily}"
inline false
status open

\begin_layout Plain Layout

\begin_inset Caption

\begin_layout Plain Layout
Macro with two arguments
\end_layout

\end_inset

LoopMacro: MACRO
\end_layout

\begin_layout Plain Layout

           ld  hl,
\backslash
1
\end_layout

\begin_layout Plain Layout

           ld  c,
\backslash
2
\end_layout

\begin_layout Plain Layout

           xor a,a
\end_layout

\begin_layout Plain Layout

.loop
\backslash
@    ld  [hl+],a
\end_layout

\begin_layout Plain Layout

           dec c
\end_layout

\begin_layout Plain Layout

           jr  nz,.loop
\backslash
@
\end_layout

\begin_layout Plain Layout

           ENDM
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The macro now accepts two arguments.
 The first being an address and the second being a byte count.
 The macro will then set all bytes in this range to zero.
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\ttfamily}"
inline false
status open

\begin_layout Plain Layout

\begin_inset Caption

\begin_layout Plain Layout
Invoking Macro with arguments
\end_layout

\end_inset

           LoopMacro MyVars,54
\end_layout

\end_inset


\end_layout

\begin_layout Standard
You can specify up to nine arguments when calling a macro.
 Arguments are passed as string equates, there's no need to enclose them
 in quotes.
 As the arguments are considered strings, this means that it's a good idea
 to use brackets around 
\backslash
1-
\backslash
9 if you perform further calculations on them.
 Consider the following scenario:
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\ttfamily}"
inline false
status open

\begin_layout Plain Layout

\begin_inset Caption

\begin_layout Plain Layout
Macro argument caveat
\end_layout

\end_inset

PrintValue: MACRO
\end_layout

\begin_layout Plain Layout

            PRINTV 
\backslash
1*2
\end_layout

\begin_layout Plain Layout

            ENDM
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

            PrintValue 1+2
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Here the assembler will print the value 5 on screen and not 6 as you might
 expect.
 The solution is to enclose 
\backslash
1 in brackets:
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\ttfamily}"
inline false
status open

\begin_layout Plain Layout

\begin_inset Caption

\begin_layout Plain Layout
Macro argument caveat fix
\end_layout

\end_inset

PrintValue: MACRO
\end_layout

\begin_layout Plain Layout

            PRINTV (
\backslash
1)*2
\end_layout

\begin_layout Plain Layout

            ENDM
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Sometimes it may be necessary to pass a comma into a macro.
 To do this, the macro argument can be enclosed in angle brackets:
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\ttfamily}"
inline false
status open

\begin_layout Plain Layout

\begin_inset Caption

\begin_layout Plain Layout
Passing a comma to a macro
\end_layout

\end_inset

PrintString: MACRO
\end_layout

\begin_layout Plain Layout

             lea  .string
\backslash
@(PC),a0
\end_layout

\begin_layout Plain Layout

             jsr  _print
\end_layout

\begin_layout Plain Layout

             bra  .skip
\backslash
@
\end_layout

\begin_layout Plain Layout

.string
\backslash
@    dc.b 
\backslash
1
\end_layout

\begin_layout Plain Layout

             EVEN
\end_layout

\begin_layout Plain Layout

.skip
\backslash
@
\end_layout

\begin_layout Plain Layout

             ENDM
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

             PrintString <"Hello,"," world",0>
\end_layout

\end_inset


\end_layout

\begin_layout Subsection*
The special argument 
\backslash
0
\end_layout

\begin_layout Standard
Particularly useful on MC680x0, it's also possible to use the special argument
 
\backslash
0.
 To pass a value into 
\backslash
0 you append a dot (.) followed by the value to the macro name.
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\ttfamily}"
inline false
status open

\begin_layout Plain Layout

\begin_inset Caption

\begin_layout Plain Layout
Macro argument 
\backslash
0
\end_layout

\end_inset

push: MACRO
\end_layout

\begin_layout Plain Layout

      movem.
\backslash
0 
\backslash
1,-(sp)
\end_layout

\begin_layout Plain Layout

      ENDM
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

      push.l   d0-a6
\end_layout

\end_inset


\end_layout

\begin_layout Subsection*
SHIFT
\begin_inset Index
status open

\begin_layout Plain Layout
SHIFT
\end_layout

\end_inset


\end_layout

\begin_layout Standard
SHIFT is a command only available in macros and particularly useful in REPT-bloc
ks.
 It "shifts" the macro arguments one position "to the left" - 
\backslash
1 will get 
\backslash
2's value, 
\backslash
2 will get 
\backslash
3's value and so forth.
\end_layout

\begin_layout Subsection*
Final notes
\end_layout

\begin_layout Standard
A colon (:) following the macro-name is required, macros cannot be exported
 or imported and it's valid to call a macro from a macro (even the same
 one for recursive behaviour).
\end_layout

\begin_layout Chapter*
Gameboy backend
\end_layout

\begin_layout Section*
Numeric formats
\end_layout

\begin_layout Standard
The Gameboy backend supports an additional numeric format:
\end_layout

\begin_layout Description
Gameboy
\begin_inset space ~
\end_inset

graphics `00112233
\end_layout

\begin_layout Standard
The values are actually pixel values.
 The values are converted from chunky data format to the planar format as
 used in the Gameboy.
\end_layout

\begin_layout Section*
Sections
\end_layout

\begin_layout Standard
The Gameboy supports several banks of code and data, in addition to fixing
 a section to a specific address, it's also possible to force it into a
 specific bank:
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\ttfamily}"
inline false
status open

\begin_layout Plain Layout

\begin_inset Caption

\begin_layout Plain Layout
Section fixed to address and bank
\end_layout

\end_inset

SECTION "FixedSection",DATA[$1100],BANK[3]
\end_layout

\end_inset


\end_layout

\begin_layout Standard
It's also possible to only specify the bank:
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\ttfamily}"
inline false
status open

\begin_layout Plain Layout

\begin_inset Caption

\begin_layout Plain Layout
Section fixed to bank
\end_layout

\end_inset

SECTION "FixedSection",CODE,BANK[3]
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset CommandInset index_print
LatexCommand printindex

\end_inset


\end_layout

\end_body
\end_document
